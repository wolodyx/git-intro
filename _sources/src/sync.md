# Синхронизация с удаленными хранилищами

В этом разделе мы:
* научимся управлять удаленными хранилищами командой `git remote`: добавлять, убирать, переименовывать псевдонимы, просматривать дополнительные сведения;
* научимся работать с отслеживаемыми ветками;
* отправлять коммиты в удаленное хранилище командой `git push`;
* принимать коммиты из удаленного хранилища командами `git fetch` и `git pull`;
* сохранить пароль;

Смоделируем групповую работу над проектом.


## Работа с одним удаленным хранилищем

Для работы с удаленным хранилищем нам необходимо знать как минимум о трех командах: `git fetch`, `git push`, `git pull`.
<!-- `git fetch` и `git push` -->
Команда `git fetch` забирает из удаленного хранилища изменения.
Но чтобы изменения там появились, их необходимо отправить туда.
Команда `git push` отправляет изменения из локального хранилища в удаленное.

```{figure} ./images/fetch-push.png
```

<!-- git pull -->
Команда `git pull` забирает изменения из удаленного хранилища и сливает их с текущими.
Она представляет последовательность команд `git fetch` и `git merge`.

Зная эти команды, разберем сценарий [`one-remote-and-two-locals.sh`](../examples/one-remote-and-two-locals.sh), в котором два локальных хранилища взаимодействуют через удаленное.
Сценарий разбит на четыре эпизода, поочередно наполняющих файл `main.c` контентом в каждом из локальных хранилищ.
Сначала первое хранилище отправляет в удаленное пустой файл, а второе хранилище заполняет его содержимым
```
main()
{
    return 0;
}
```
Затем первое хранилище добавляет в него тип возвращаемого значения, а второе -- список аргументов функции `main`.
Первое хранилище успевает синхронизироваться с удаленным раньше, чем второе.
Поэтому второму приходится слиться с изменениями из удаленного, разрешив попутно конфликт слияния:
```
<<<<<<< HEAD
main(int argc, char** argv)
=======
int main()
>>>>>>> origin/main
{
    return 0;
}
```

```{figure} ./images/one-remote-and-two-locals.png
```


## Локальные, удаленные и отслеживаемые ветки

В сценарии выше неопределенность представляет аргумент `origin/main` команды `git merge`.
Чтобы разобраться в нем нам следует понять как обозначают удаленные хранилища в локальном, что такое локальные, удаленные и отслежваемые ветки.

<!-- Связь между локальным и удаленным хранилищем -->
Склонированное локальное хранилище сохраняет связь со своим удаленным хранилищем.
Git удаленному хранилищу по умолчанию задает псевдоним `origin`.
Псевдоним заменяет более сложный в наборе url-адрес.
Другие команды, когда им потребуется обратиться к удаленному хранилищу, возьмут адрес связанный с именем `origin`.

Команда `git remote` перечисляет список сохраненных удаленных хранилищ, связанных с локальным.
`origin` будет показываться всегда.
Чтобы увидеть адреса хранилищ, выполните команду выше с опцией `-v`:
```bash
$ git remote -v
origin	/home/bob/projects/git-examples/./remote.git (fetch)
origin	/home/bob/projects/git-examples/./remote.git (push)
```

В подробном выводе с хранилищем связаны два адреса.
Первый из них для чтения, а второй -- для записи.
Здесь они совпадают, но в общем случае отличаются.

После клонирования мы получаем идентичную локальную копию удаленного хранилища.
В обоих хранилищах содержатся ветки, состояние которых в начальный момент совпадают.
Но со временем ветки разойдутся: локальные будут наращиваться коммитами от автора локального хранилища, а удаленные -- коммитами от других участников команды.
В моменты слияния к веткам приходится обращаться, например, для слияния текущей ветки main с одноименной удаленной.

Как различить локальную и удаленную ветки, если их имена совпадают?
Удаленным веткам в локальном хранилище дают имена, составленные от имени удаленного хранилища: ветка `main` удаленного хранилища `origin` будет обозначена как `origin/main`.
В отличие от локальной ветки, указатель удаленной ветки перемещается только после синхронизации с удаленным хранилищем командами `git fetch` и `git pull`.
Положение удаленной ветки актуально на момент последней синхронизации.
Локальная ветка перемещается только при создании коммита.

В удаленные ветки нельзя создавать коммиты.
Для этого сначала следует создать локальную ветку по удаленной.
Когда такая локальная ветка создается, в ней сохраняется связь с удаленной и ее называют отслеживающей.
При клонировании хранилища, автоматически создается локальная ветка `main` (`master`), отслеживающая удаленную ветку `origin/main` (`origin/master`).
Команда `git pull` самостоятельно определяет какую локальную ветку с какой удаленной слить.


## Работа с несколькими удаленными хранилищами

```{figure} ./images/two-remotes.png
```

<!--
Сохранить имя пользователя и пароль: `git config --global credentials.helper store`.
-->

<!--
* git remote add <shortname> <url>
* git remote rename <repo>
* git remote rename <oldname> <nowname>
* git remote remove <name>
* git remote show <repo>
* git fetch [<repo>]
* git pull [<repo>]
* git push [<repo> [<branch>]]

* удаленные ссылки: ветки, теги;
* ветка слежения -- это ссылка на определенное состояние удаленных веток; <remote>/<branch>
* локальная ветка, только они редактируемые;
* Git при клонировании автоматически создает локальную ветку для основной ветки. Для остальных веток она так не делает.
-->

