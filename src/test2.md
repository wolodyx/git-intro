# Проверочная работа


## Контрольные вопросы

1. Что такое Git-сервер? Какие задачи он выполняет?
1. Как происходит взаимодействие между Git-сервером и Git-клиентом?
1. Кто предоставляет услуги Git-сервера?
  Какие еще услуги они предоставляют дополнительно?
1. Чем является GitHub?
1. Чем является GitLab?
1. Чем отличается публичный проект (хранилище) от приватного?
1. В чем отличие между GitHub и GitLab?
1. Какие публичные проекты открытого ПО вам известны?
1. Какие варианты вы имеете для размещения ваших проектов?

1. Какой командой копируется удаленное хранилище из Git-сервера?
1. Склонируйте хранилище по адресу `https://github.com/pmodels/mpich.git`.
1. Каким способом можно выбрать место в файловой системе для локального хранилища?
1. Как можно извлечь адрес хранилища у проекта на GitHub?
1. Как можно ускорить загрузку хранилища по сети?
1. Чем отличаются публичное хранилище от приватного с точки зрения доступа к ним?
1. Какие элементы можно выделить из адреса удаленного хранилища?
1. Какие протоколы доступа к удаленному хранилищу Git вы знаете?
  Какими из них вы уже пользовались?
1. Какую возможность дает привязка хранилища к имени пользователя?

1. Что такое ветка?
1. Когда появляется необходимость в ветках?
1. Какие бывают ветки? Для чего они предназначены?
1. Что означает "текущая ветка"?
1. Как узнать, которая из веток текущая?
1. Как лучше всего отобразить дерево коммитов в графовом представлении?
1. Как посмотреть список веток с последними коммитами для каждой?
1. Как создать новую ветку?
1. Как переключиться на другую ветку?
1. Как одной командой создать новую ветку и переключиться на нее?

1. Когда возникает необходимость в объединении изменений?
1. Какие проблемы могут возникнуть при неудачном объединении изменений?
1. Какие способы объединения изменений вам известны?
1. Что делает команда `git merge`?
1. Расскажите про перенос изменений коммитом слияния.
1. Расскажите про перемотку вперед.
1. Расскажите про перебазирование.
1. Когда следует отказаться от перемотки вперед и перебазирования?
1. Что такое конфликт слияния?
  В каких случаях возникает конфликт?
1. Как разрешается конфликт слияния?
1. Для чего используют KDiff3?
1. В чем состоит обслуживание веток?

1. В чем состоит синхронизация хранилищ?
1. Какие команды используют для синхронизации хранилища?
1. Чем команда `git fetch` отличается от `git pull`?
1. Для чего существует псевдоним удаленного хранилища?
1. Чем отличается локальная ветка от удаленной?
1. Что значит "отслеживающая ветка"?
1. Расскажите про централизованную модель взаимодействия участников проекта.
1. Расскажите про модель с интеграционным менеджером для взаимодействия участников проекта.
1. Расскажите про модель с диктатором и помощниками для взаимодействия участников проекта.


## Упражнения

1. Создайте удаленное хранилище и склонируйте его в два локальных.
1. Повторите структуру дерева коммитов, показанных на рисунке ниже.
1. Создайте хранилище с ветками `main` и `train`, в каждом из которых по одному коммиту.
  Перенесите изменения из ветки `main` в `train`, создайте дополнительный коммит в `train`, а затем перенесите все изменения обратно в `main`.
1. Создайте хранилище со структурой из рисунка ниже.
  Перебазируйте тематическую ветку в основную.
  Проверьте, какие поля изменились у коммитов.
1. Создайте удаленное и два локальных хранилища.
  Внесите отдельные изменения в локальные хранилища.
  Заберите изменения из одного локального хранилища в другое в отдельную ветку и удалите ненужное хранилище.
1. Перенесите коммит из одного хранилища в другое через патч.

```{figure} ./images/branch-3.png
```


## Замечания по упражнениям

Для выполнения некоторых упражнений необходимо в командной строке выполнить большое количество команд.
Исполнение команд можно автоматизировать, если набранные команды оформить в виде сценария.
При этом возникает сложность при редактировании файлов, которое происходит интерактивно.
Но и этот процесс можно автоматизировать, если воспользоваться утилитами `cat`, `echo`, `sed` и перенаправлением потоков.

Конструкция ниже формирует файл `main.c` с главной функцией `main` из четырех строчек кода.
Маркер `EOF` (может быть произвольным текстом) показывает конец ввода строк.
``` bash
cat > main.c << EOF
main()
{
    return 0;
}
EOF
```

Та же самая конструкция, но с перенаправлением в файл `main.c` через `>>` уже добавляет в конец файла последующие строки.
``` bash
cat >> main.c << EOF
void func()
{
}
EOF
```

Чтобы отредактировать конкретную строку, воспользуйтесь утилитой `sed`.
Команда ниже отредактирует (опция `-i`) файл `main.c`: заменит в первой строке подстроку `main()` на `int main()`.
```
sed -i '1s/main()/int main()/' main.c
```

```{note}
За примерами обращайтесь в файлы каталога `examples/` данного проекта.
```

