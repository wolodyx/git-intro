# Фиксация изменений


## Введение

Команда `git commit` фиксирует изменения в хранилище, добавляя во внутреннюю базу данных запись, называемую *коммитом*.
С коммитом связан следующий набор данных:
* изменения в файлах;
* сообщение, описывающее изменения;
* дата и время фиксации;
* имя и электронная почта автора изменений.

Дату и время фиксации Git берет из системного времени в момент выполнения команды.
Локальное системное время должно быть синхронизировано с мировым, чтобы не возникло противоречий в данных при обмене изменениями с другим хранилищем.
Имя и электронная почта автора Git берет из настроек.
Там они были заданы при [настройке Git](config.md).

```{warning}
Фиксация завершится с ошибкой, если ранее при настройке Git не указали имя и электронную почту пользователя.
```

Прежде чем начать фиксировать изменения в файлах, необходимо познакомиться с состояниями файлов, наблюдения и управления ими.
Это осуществляется командами `git status` и `git add`.


## Состояния файлов

Познакомимся с состояниями файлов, в которых они могут быть для Git.
Научимся видеть эти состояния командой `git status`.

<!-- Отслеживаемые и неотслеживаемые файлы -->
Git интересуют файлы в рабочем каталоге, но не за его пределами.
Интерес выражается в том, что в последующем пользователю будет предложено добавить изменения в них в историю хранилища.
Все файлы в рабочем каталоге делятся на *отслеживаемые* (tracked) и *неотслеживаемые* (untracked).
К отслеживаемым файлам относятся те, которые до этого присутствовали в ревизии, из которой извлечена рабочая копия.
Недавно созданные файлы, еще не попавшие в историю или индекс (который мы рассмотрим ниже), будут относится к категории неотслеживаемых.

```{figure} ./images/file-states.png
```

<!-- Неотслеживаемые файлы и артефакты сборки -->
В процессе работы над проектом в рабочем каталоге появляются новые файлы, например, сгенерированные системой сборки, компилятором, тестовой системой, архиватором.
Сюда входят объектные, исполняемые, временные и архивные файлы.
Эти файлы производны от исходных кодов, сценариев сборки и представляют краткосрочный интерес.
Их еще называют *артефактами сборки*.
Даже если их удалить из файловой системы, они могут быть повторно получены пересборкой программы.
Считается хорошей практикой держать артефакты сборки в отдельном каталоге, как например в `CMake`.
Но система сборки `Make` создает артефакты рядом с файлами исходным кодом, что засоряет рабочий каталог.

<!-- Файл `.gitignore` -->
Таким образом, все неотслеживаемые файлы можно разделить на две категории:
* новые файлы, добавляемые в скором времени в следующую ревизию;
* игнорируемые, путь в хранилище которым закрыт навсегда.

Чтобы файлы из первой категории не потерялись среди многочисленных файлов второй, в Git добавлены списки игнорируемых файлов и каталогов.
Они перечисляются в файле `.gitignore` в формате регулярных выражений.
Сам файл располагается в корне рабочего каталога.
Содержимое этого файла зависит от используемого языка программирования, библиотек и инструментов.
Разработчики GitHub в открытом проекте [gitignore](https://github.com/github/gitignore) собрали примеры этих файлов с привязкой к используемым программным технологиям.

<!-- Отслеживаемые файлы -->
Отслеживаемые файлы составляют проект программы и основую для следующей его ревизии.
Все файлы делятся на три части:
* зафиксированные;
* измененные;
* проиндексированные.

<!-- Зафиксированный и измененный файлы -->
После извлечения рабочей копии всей файлы относятся к зафиксированным.
Если внести изменения в зафиксированный файл, то он перейдет в измененное состояние.
Если откатить изменения у измененного файла, то он перейдет обратно в зафиксированное состояние.

<!-- Проиндексированный файл -->
Индексированные файлы предназначены для включения изменений в историю.
По-другому, индексированный файл рассматривается как измененный файл, помещенный в специальную область, называемую *индексом*.
Индекс -- это область, дополнительная к рабочей копии и хранилищу.
Физически она расположена внутри хранилища, не передается и не клонируется.

```{figure} ./images/git-index.png
```

<!-- `git status` и состояние файлов -->
Состояние файлов в рабочем каталоге показывает команда `git status`.
В примере ниже она показывает, что файл `LampServer.cpp` изменен и неотслеживаются файлы из каталога `build/`.

``` console
skt@home:~/MyProjects/RemoteLamps$ git status
На ветке main
Ваша ветка обновлена в соответствии с «origin/main».

Изменения, которые не в индексе для коммита:
  (используйте «git add <файл>…», чтобы добавить файл в индекс)
  (используйте «git restore <файл>…», чтобы отменить изменения в рабочем каталоге)
	изменено:      LampServer.cpp

Неотслеживаемые файлы:
  (используйте «git add <файл>…», чтобы добавить в то, что будет включено в коммит)
	build/

нет изменений добавленных для коммита
(используйте «git add» и/или «git commit -a»)
```


## Работа с индексом

<!-- Работа с индексом -->
Для изменения текстового файла достаточно редактора.
Команда `git add` помещает фиксируемые файлы в индекс, еще говорят -- индексирует файлы.
Эта же команда применима и к неотслеживаемым файлам, чтобы превратить их в историю.

<!-- `git add` и шаблоны в аргументах -->
`git add *.c`.
`git add test*.cpp`

Проиндексируем измененный файл командой `git add LampServer.cpp` и еще раз посмотрим на вывод команды `git status`:

``` console
skt@home:~/MyProjects/RemoteLamps$ git status
На ветке main
Ваша ветка обновлена в соответствии с «origin/main».

Изменения, которые будут включены в коммит:
  (используйте «git restore --staged <файл>…», чтобы убрать из индекса)
	изменено:      LampServer.cpp

Неотслеживаемые файлы:
  (используйте «git add <файл>…», чтобы добавить в то, что будет включено в коммит)
	build/
```

Команда `git status` имеет подробный вывод и полезна в начале.
Но с опытом эта многословность начинает мешать.
Опция `-s` делает вывод более компактным:

``` console
skt@home:~/MyProjects/RemoteLamps$ git status -s
M  LampServer.cpp
?? build/
```

<!-- Просмотр изменений -->


## Фиксация изменений

Подготовив индекс, мы можем зафиксировать изменения командой `git commit`.
Команда откроет текстовый файл.

`git commit`

Если описание коммита однострочное, то его можно передать команде через аргумент опции `-m`:
```
git commit -m "Описание изменений"
```

<!-- Фиксация изменений без добавления в индекс -->
```
git commit -a
```

<!-- Отображение изменений в редакторе -->
```
git commit -v
```


## Использованные источники

* [A collection of .gitignore templates](https://github.com/github/gitignore)


## Контрольные вопросы

1.


## Упражнения

1. Покажите пример файла `.gitignore` для языка программирования C++ от разработчиков GitHub.

