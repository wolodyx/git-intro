# Фиксация изменений


## Введение

В этом разделе мы познакомимся с командами `git commit`, `git add`, `git status`.

Команда `git commit` фиксирует изменения в хранилище, добавляя во внутреннюю базу данных запись, называемую *коммитом*.
С коммитом связан следующий набор данных:
* изменения в файлах;
* сообщение, описывающее изменения;
* дата и время фиксации;
* имя и электронная почта автора изменений.

Дату и время фиксации Git берет из системного времени в момент выполнения команды.
Локальное системное время должно быть синхронизировано с мировым, чтобы не возникло противоречий в данных при обмене изменениями с другим хранилищем.
Имя и электронная почта автора Git берет из настроек.
Там они были заданы при [настройке Git](config.md).
Если настройка не была проведена, то выполнить фиксацию не получится.

Прежде чем начать фиксировать изменения в файлах, необходимо познакомиться с состояниями файлов, наблюдения и управления ими.
Это осуществляется командами `git status` и `git add`.


## Отслеживаемые файлы

Для Git все файлы можно поделить на две части: те, что представляют интерес и те, что не представляют.
Первые файлы называют *отслеживаемыми* (tracked), а вторые -- *неотслеживаемыми* (untracked).
Отслеживаемые файлы считаются те, которые до этого присутствовали в ревизии, из которой извлечена рабочая копия.
Если файл еще неизвестен Git, то она будет указывать на это, предлагая добавить его хранилище.

<!-- Неотслеживаемые файлы -->
В процессе работы в рабочем каталоге появляются новые файлы, например, сгенерированные системой сборки, компилятором, тестовой системой, архиватором.
Сюда входят объектные, исполняемые, временные и архивные файлы.
Эти файлы производны от исходных кодов, сценариев сборки и не представляют интерес.
Их еще называют *артефактами сборки*.
Даже если их удалить из файловой системы, они будут повторно получены пересборкой программы.
Хорошей практикой является держать артефакты сборки в отдельном каталоге сборки, как например в `CMake`.
Но система сборки `Make` создает артефакты сборки рядом с файлами исходным кодом, что засоряет рабочий каталог.

<!-- Файл `.gitignore` -->
Таким образом, все неотслеживаемые файлы можно поделить на две части:
* те, что никогда не попадут в хранилище;
* и те, что попадут через время.

Файл `.gitignore` перечисляет неотслеживаемые файлы и каталоги в формате регулярных выражений.


## Состояние файлов

<!-- `git status` или информация о состоянии файлов -->
Команда `git status` показывает состояния отслеживаемых и список неотслеживаемых файлов.
В примере ниже она показывает, что файл `LampServer.cpp` изменен и неотслеживаются файлы из каталога `build/`.

``` console
skt@home:~/MyProjects/RemoteLamps$ git status
На ветке main
Ваша ветка обновлена в соответствии с «origin/main».

Изменения, которые не в индексе для коммита:
  (используйте «git add <файл>…», чтобы добавить файл в индекс)
  (используйте «git restore <файл>…», чтобы отменить изменения в рабочем каталоге)
	изменено:      LampServer.cpp

Неотслеживаемые файлы:
  (используйте «git add <файл>…», чтобы добавить в то, что будет включено в коммит)
	build/

нет изменений добавленных для коммита
(используйте «git add» и/или «git commit -a»)
```


## Работа с индексом

<!-- Измененный, индексированный и зафиксированный файлы -->
Отслеживаемые файлы могут быть в трех состояниях: *неизменными*, *измененными* и *подготовленными к фиксации*.
После извлечения рабочей копии всей файлы относятся к неизменным.
Если отслеживаемый файл был отредактирован, то он рассматривается измененным.
Перед фиксацией измененный файл должен быть выбран -- помещен в *область индексирования* или, коротко, *индекс*.
Индекс является третьей областью, где хранятся файлы, дополнительно к рабочей копии и хранилищу.

<!-- Работа с индексом -->
Команда `git add` помещает фиксируемые файлы в индекс, еще говорят -- индексирует файлы.
Эта же команда применима и к неотслеживаемым файлам, чтобы превратить их в историю.

<!-- `git add` и шаблоны в аргументах -->
`git add *.c`.
`git add test*.cpp`

Проиндексируем измененный файл командой `git add LampServer.cpp` и еще раз посмотрим на вывод команды `git status`:

``` console
skt@home:~/MyProjects/RemoteLamps$ git status
На ветке main
Ваша ветка обновлена в соответствии с «origin/main».

Изменения, которые будут включены в коммит:
  (используйте «git restore --staged <файл>…», чтобы убрать из индекса)
	изменено:      LampServer.cpp

Неотслеживаемые файлы:
  (используйте «git add <файл>…», чтобы добавить в то, что будет включено в коммит)
	build/
```

Команда `git status` имеет подробный вывод и полезна в начале.
Но с опытом эта многословность начинает мешать.
Опция `-s` делает вывод более компактным:

``` console
skt@home:~/MyProjects/RemoteLamps$ git status -s
M  LampServer.cpp
?? build/
```

<!-- Просмотр изменений -->


## Фиксация изменений

Подготовив индекс, мы можем зафиксировать изменения командой `git commit`.
Команда откроет текстовый файл.

`git commit -v`

Если описание коммита однострочное, то его можно передать команде через аргумент опции `-m`:
```
git commit -m "Описание изменений"
```


## Контрольные вопросы

1.


## Упражнения

1.

