# Объединение изменений

<!--
Тема со слиянием изменением обширна за счет
-->

В этом разделе мы:
* узнаем о трех способах объединения изменений: слиянии, перемотке и перебазировании;
* познакомимся с командой `git merge`;
* научимся разрешать конфликты слияния.

Бывает необходимым объединить результаты работы двух разработчиков.
Слияние изменений возникает при объединении веток, а также при обновлении рабочего каталога до последней ревизии основной ветки.
при слиянии файлов не следует терять данные и не нарушить целостность проекта.
Операция слияния происходит автоматически (без вмешательства человека), если изменения не пересекаются, т.е. выполнены в разных файлах или в разных строках одного файла.


## Перенос изменений коммитом слияния

<!-- Команда `git merge` и слияние с коммитом -->
Команда `git merge` переносит изменения из одной ветки в другую.
Представим ситуацию, когда есть дерево коммитов с основной веткой `master` и тематической `bugfix`.
В `bugfix` двумя коммитами исправлена ошибка.
За время работы над `bugfix` в основной ветке появился один коммит.
Указатель на текущую ветку `HEAD` показывает на `master`.
В этом состоянии команда `git merge bugfix` переносит изменения из ветки `bugfix` в текущую ветку `master` через *коммит слияния* с идентификатором `2a5`.
Текущая ветка `master` перемещается на этот новый коммит.

```{figure} ./images/branch-6.png
```

<!-- Удаление ветки `git branch -d <branch>` -->
Указатель функциональной ветки `bugfix` после объединения не переместился.
Этой веткой еще можно воспользоваться и развивать ее, но смысла в этом нет, так как она выполнила свою роль.
Она может быть удалена.
При удалении мы не потеряем ее коммиты, так как они теперь стали достижимыми из основной ветки.
Удаление ветки приведет только к удалению указателя на коммит.
Команда `git branch -d bugfix` успешно удалит ветку `bugfix`.
Возникает вопрос, а не хранил ли именованный указатель ветки информацию об исправленной ошибке?
Может ли пользователь Git по отдельным описаниям коммитов функциональной ветки сделать вывод, что здесь происходило исправление конкретной ошибки?
Так вот, информация об исправлении ошибки должна быть ясно прописана в описании коммита слияния `2a5`.
Коммит слияния как бы вносит изменения в ветку скопом.


## Перемотка вперед

Объединение веток упростится, если в ветке, куда переносятся изменения, отсутствуют коммиты.
Пример такой ситуации показан на рисунке ниже.
Здесь достаточно переместить указатель ветки `master` к последнему коммиту `bugfix`.
Этот прием называется *перемоткой вперед*, от английского `fast forward`.

```{figure} ./images/branch-4.png
```

Но и в этой ситуации можно создать коммит слияния, если явно отказаться от перемотки опцией `--no-ff`.
```
git merge --no-ff bugfix
```
Такой выбор объясняется тем, что автор не хочет, чтобы коммиты его ветки не стали коммитами основной ветки, так как каждая из них не удовлетворяет условию завершенности.
А таким условием обладает только коммит слияния.

```{figure} ./images/branch-4.1.png
```


## Перебазирование

Перебазирование -- это перенос последовательности коммитов на другой коммит.
Графически это выглядит как отрезание части ветки с места ветвления и перенос ее в другое место.
Те коммиты, от которых ветка была отсоединена и к которым закреплена, называют базовыми.
Отметим, что при у переносимых коммитов меняются идентификаторы, так как меняются родители.

Представим знакомую ситуацию на рисунке ниже с двумя ветками `master` и `bugfix`.
Она отличается от вышеприведенного тем, что текущая ветка здесь `bugfix`.
Команда `git rebase master` перенесет текущую ветку `bugfix` на ветку `master`.
Чтобы закончить объединение следует или перемотать ветку `master` до `bugfix` или создать коммит слияния.

```{figure} ./images/branch-5.png
```

<!-- Когда не следует использовать перебазирование -->
Перебазирование, в отличие от перемотки и слияния, изменяет историю, удаляя существующие коммиты и связи между ними.
Это может усложнить объединение изменений, если кто-то еще использовал удаляемые коммиты.
Отсюда вытекает важное правило.

```{warning}
Нельзя перебазировать публичные ветки, (ветки, которые кто-то еще использует).
В противном случае, во время объединения дерева коммитов двух хранилищ, удаленные коммиты вернутся обратно.
В результате в истории будут две копии коммитов, вносящих одни и те же изменения.
```

<!-- Когда следует использовать перебазирование? -->
Перебазирование подходит, если вы каждым коммитом вносите в проект полностью оформленную работу.
Примеры изменений, которые не удовлетворяют этому условию:
* не компилируются;
* не позволяют запустится программе;
* вносят дополнительные ошибки.

Перебазирование, как и перемотка, сохраняет историю изменений линейной.
Такая история проще для просматривания и изучения.


## Разрешение конфликтов слияния

Конфликтом слияния называют ситуацию, при которой изменения не могут быть слиты автоматически.
Для разрешения конфликта требуется внимание разработчика.

Когда невозможно автоматически слить изменения?
Невозможно объединять изменения в двоичных файлах как изображения, аудио и видео.
Здесь остается только выбрать один из двух вариантов или заново отредактировать файл с учетом предыдущих изменений.
Конфликты слияния возникают в текстовых файлах, если были по разному изменены одна и та же строка или пересекаются фрагменты патчей.
Также такое происходит, если один из участников изменил файл, а второй удалил его.

При конфликте слияния команда `git merge` прерывается с сообщением об ошибке.

<!-- Алгоритм слияния изменений -->
Слияние выполняется для каждого файла.
Базовая, локальная и серверная ревизии.
Специальный инструмент `diff3`, `kdiff3`, `WinMerge`.
Разметки в объединяемых файлах.

Список веток, слитых с текущей, покажет команда `git branch --merged`.
Эти ветки можно безопасно удалить.
Команда `git branch --no-merged` покажет список веток, неслитых с текущей.
Такие ветки нельзя удалить, не потеряв их коммиты.
Если все-таки нужно удалить такую ветку, то выполните команду `git branch -D <branch-name>`.


## Обслуживание веток

<!--
* `git branch --no-merged main` покажет ветки, неслитые с `main`.
* `git log --no-merges`
-->

